#!/bin/bash
# QuillKernel Pre-commit Hook
# Runs static analysis on changed files before commit

# Enable strict error handling
set -e

echo "═══════════════════════════════════════════════════════════════"
echo "         QuillKernel Pre-commit Checks"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Get list of staged C files
STAGED_C_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.c$' || true)
STAGED_H_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.h$' || true)

if [ -z "$STAGED_C_FILES" ] && [ -z "$STAGED_H_FILES" ]; then
    echo "No C/H files to check"
    exit 0
fi

ERRORS=0

# 1. Check for debugging code
echo "1. Checking for debug code..."
echo "----------------------------"

DEBUG_FOUND=0
for file in $STAGED_C_FILES; do
    if grep -n "printk.*KERN_DEBUG\|pr_debug\|//.*TODO\|//.*FIXME\|//.*XXX" "$file" > /dev/null 2>&1; then
        echo -e "${YELLOW}[WARN]${NC} Debug code in $file:"
        grep -n "printk.*KERN_DEBUG\|pr_debug\|//.*TODO\|//.*FIXME\|//.*XXX" "$file" | head -3
        DEBUG_FOUND=$((DEBUG_FOUND + 1))
    fi
done

if [ $DEBUG_FOUND -eq 0 ]; then
    echo -e "${GREEN}[PASS]${NC} No debug code found"
else
    echo -e "${YELLOW}[WARN]${NC} Found debug code in $DEBUG_FOUND files"
fi

echo ""

# 2. Check coding style (simplified)
echo "2. Checking coding style..."
echo "-------------------------"

STYLE_ERRORS=0
for file in $STAGED_C_FILES $STAGED_H_FILES; do
    # Check for tabs vs spaces (kernel uses tabs)
    if grep -n "^    " "$file" > /dev/null 2>&1; then
        echo -e "${RED}[FAIL]${NC} Spaces instead of tabs in $file"
        STYLE_ERRORS=$((STYLE_ERRORS + 1))
    fi
    
    # Check for trailing whitespace
    if grep -n "[[:space:]]$" "$file" > /dev/null 2>&1; then
        echo -e "${RED}[FAIL]${NC} Trailing whitespace in $file"
        grep -n "[[:space:]]$" "$file" | head -3
        STYLE_ERRORS=$((STYLE_ERRORS + 1))
    fi
    
    # Check line length (warn at 80, error at 100)
    LONG_LINES=$(awk 'length > 100' "$file" | wc -l)
    if [ $LONG_LINES -gt 0 ]; then
        echo -e "${RED}[FAIL]${NC} $LONG_LINES lines over 100 chars in $file"
        STYLE_ERRORS=$((STYLE_ERRORS + 1))
    fi
done

if [ $STYLE_ERRORS -eq 0 ]; then
    echo -e "${GREEN}[PASS]${NC} Coding style OK"
else
    ERRORS=$((ERRORS + STYLE_ERRORS))
fi

echo ""

# 3. QuillKernel specific checks
echo "3. QuillKernel specific checks..."
echo "-------------------------------"

# Check for unchecked memory allocations
UNCHECKED_ALLOC=0
for file in $STAGED_C_FILES; do
    # Look for kmalloc/kzalloc not followed by null check
    if grep -A2 "kmalloc\|kzalloc\|kcalloc" "$file" | grep -v "if.*==" > /dev/null 2>&1; then
        echo -e "${RED}[FAIL]${NC} Possible unchecked allocation in $file"
        UNCHECKED_ALLOC=$((UNCHECKED_ALLOC + 1))
        ERRORS=$((ERRORS + 1))
    fi
done

# Check for medieval theme consistency
THEME_ISSUES=0
for file in $STAGED_C_FILES; do
    # Check if file contains SquireOS/medieval content
    if grep -i "squire\|jester\|quill\|medieval" "$file" > /dev/null 2>&1; then
        # Ensure proper capitalization
        if grep -n "squireos\|Squireos\|SQUIREOS" "$file" > /dev/null 2>&1; then
            if ! grep -n "SquireOS" "$file" > /dev/null 2>&1; then
                echo -e "${YELLOW}[WARN]${NC} Inconsistent SquireOS capitalization in $file"
                THEME_ISSUES=$((THEME_ISSUES + 1))
            fi
        fi
    fi
done

if [ $UNCHECKED_ALLOC -eq 0 ] && [ $THEME_ISSUES -eq 0 ]; then
    echo -e "${GREEN}[PASS]${NC} QuillKernel checks passed"
fi

echo ""

# 4. Run sparse if available (quick check)
if command -v sparse > /dev/null 2>&1; then
    echo "4. Running Sparse analysis..."
    echo "---------------------------"
    
    SPARSE_ERRORS=0
    for file in $STAGED_C_FILES; do
        echo -n "  Checking $file... "
        if sparse "$file" -Wbitwise 2>&1 | grep -q "error:"; then
            echo -e "${RED}[FAIL]${NC}"
            sparse "$file" -Wbitwise 2>&1 | grep "error:" | head -2
            SPARSE_ERRORS=$((SPARSE_ERRORS + 1))
            ERRORS=$((ERRORS + 1))
        else
            echo -e "${GREEN}[PASS]${NC}"
        fi
    done
else
    echo "4. Sparse not available - skipping"
fi

echo ""

# 5. Check commit message format
echo "5. Checking commit message..."
echo "----------------------------"

# Get the commit message
if [ -f .git/COMMIT_EDITMSG ]; then
    COMMIT_MSG=$(cat .git/COMMIT_EDITMSG)
    
    # Check for conventional format
    if echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore):"; then
        echo -e "${GREEN}[PASS]${NC} Commit message follows convention"
    else
        echo -e "${YELLOW}[WARN]${NC} Consider using conventional format:"
        echo "  feat: new feature"
        echo "  fix: bug fix"
        echo "  docs: documentation"
        echo "  style: formatting"
        echo "  refactor: refactoring"
        echo "  test: tests"
        echo "  chore: maintenance"
    fi
fi

echo ""

# Summary
echo "═══════════════════════════════════════════════════════════════"
if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}All checks passed!${NC}"
    echo ""
    echo "     .~\"~.~\"~."
    echo "    /  ^   ^  \\    Thy code is worthy!"
    echo "   |  >  ◡  <  |   Proceed with the commit!"
    echo "    \\  ___  /      "
    echo "     |~|♦|~|       "
    exit 0
else
    echo -e "${RED}Found $ERRORS errors!${NC}"
    echo ""
    echo "     .~!!!~."
    echo "    / O   O \\    Fix the issues above"
    echo "   |  >   <  |   before committing!"
    echo "    \\  ~~~  /    "
    echo "     |~|♦|~|     "
    echo ""
    echo "To bypass (not recommended): git commit --no-verify"
    exit 1
fi